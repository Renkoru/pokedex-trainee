<!DOCTYPE html>
<html lang="en">
  <head>
    <title>React - 2</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="shower/themes/ribbon/styles/styles.css">
    <!-- <link href="prism.css" rel="stylesheet" /> -->
    <style>
     .shower {
       --slide-ratio: calc(16 / 9);
     }
    </style>
  </head>
  <body class="shower list">
    <header class="caption">
      <h1>React - 2</h1>
      <p>by Maxim Rurenko</p>
    </header>

    <section class="slide">
      <h2>What we have learned</h2>
      <ul>
        <li>
          UI building blocks in React are Components. Independent and reusable.
        </li>
        <li class="next">
          Component can be considered as function that takes props and returns an element
        </li>
        <li class="next">
          React 'reacts' on changes (state, props) and updates UI when it is needed.
        </li>
        <li class="next">
          Data on input -> UI on output
        </li>
      </ul>
    </section>

    <section class="slide">
      <h2>Remember about</h2>
      <ul>
        <li>
          Do Not Modify State Directly, use <b>setState()</b>
        </li>
        <li class="next">
          The data flows down. From parent to child
        </li>
        <li class="next">
          Prefere <b>'functional'</b> components instead of 'class' components.
        </li>
        <li class="next">
          Investigate Hooks in React docs, they are great!
        </li>
      </ul>
    </section>

    <section class="slide">
      <h2>Lists and Keys</h2>
      <ul>
        <li>
          A “key” is a special string attribute you need to include when creating lists of elements
        </li>
        <li class="next">
          Keys help React identify which items have changed, are added, or are removed
        </li>
        <li class="next">
          Keys should be given to the elements inside the array to give the elements a stable identity
        </li>
        <li class="next">
          The best way to pick a key is to use a string that uniquely identifies a list item among its
          siblings
        </li>
      </ul>
    </section>

    <section class="slide">
      <h2>Portals</h2>
      <p>
        Portals provide a first-class way to render children into a DOM node
        that exists outside the DOM hierarchy of the parent component.
      </p>
      <pre style="font-size: 20px">
        <code>function Component() {</code>
        <code>  return ReactDOM.createPortal(</code>
        <code>    this.props.children,</code>
        <code>    domNode</code>
        <code>  );</code>
        <code>}</code>
      </pre>
    </section>

    <section class="slide">
      <h2>Fragment</h2>
      <p>
        A common pattern in React is for a component to return
        multiple elements. Fragments let you group a list of children
        without adding extra nodes to the DOM.
      </p>
      <pre style="font-size: 14px">
        <code>&lt;React.Fragment&gt;</code>
        <code>  &lt;ChildA /&gt;</code>
        <code>  &lt;ChildB /&gt;</code>
        <code>&lt;/React.Fragment&gt;</code>
        <code>// -- Short syntax</code>
        <code>&lt;&gt;</code>
        <code>  // children here</code>
        <code>&lt;/&gt;</code>
      </pre>
    </section>

    <section class="slide">
      <h2>Forms</h2>
      <ul>
        <li>
          HTML form elements work a little bit differently from other DOM elements in React,
          because form elements naturally keep some internal state.
        </li>
        <li class="next">
          This form has the default HTML form behavior of browsing to a new page when the user submits
          the form. If you want this behavior in React, it just works.
        </li>
        <li class="next">
          But in most cases, it’s convenient to have a JavaScript
          function that handles the submission of the form and has
          access to the data that the user entered into the form.
        </li>
      </ul>
    </section>

    <section class="slide">
      <h2>Forms / Controlled Components</h2>
      <ul style="font-size: 22px;">
        <li>
          In HTML, form elements such as &lt;input&gt;, &lt;textarea&gt;, and &lt;select&gt;
          typically maintain their own state and update it based
          on user input.
        </li>
        <li class="next">
          In React, mutable state is typically kept in the state property of components,
          and only updated with setState().
        </li>
        <li class="next">
          We can combine the two by making the React state be the “single source of truth”.
        </li>
        <li class="next">
          Then the React component that renders a form also controls what
          happens in that form on subsequent user input.
        </li>
        <li class="next">
          An input form element whose value is controlled by React in
          this way is called a “controlled component”.
        </li>
      </ul>
    </section>

    <section class="slide">
      <h2>Forms / Uncontrolled components</h2>
      <p>
        In most cases, we recommend using controlled components to
        implement forms. In a controlled component, form data is
        handled by a React component. The alternative is uncontrolled
        components, where form data is handled by the DOM itself.
      </p>
      <pre>
        <code>const inputEl = useRef(null);</code>
        <code>...</code>
        <code>&lt;input type="text" ref={inputEl} /&gt;</code>
      </pre>
    </section>

    <section class="slide">
      <h2>Lifting State Up</h2>
      <ul>
        <li>
          Often, several components need to reflect the same changing data.
        </li>
        <li class="next">
          In React, sharing state is accomplished by moving it up to the closest common ancestor
          of the components that need it.
        </li>
        <li class="next">
          This is called “lifting state up”.
        </li>
        <li class="next">
          There should be a single “source of truth” for any data that changes in a React application.
        </li>
      </ul>
    </section>

    <section class="slide">
      <h2>Lifting State Up / Example</h2>
      <pre style="font-size: 18px">
        <code>&lt;ParentComponent&gt; // Shared data stored here</code>
        <code>  ...</code>
        <code>   &lt;Child1&gt;</code>
        <code>     // Using shared data from props</code>
        <code>   &lt;/Child1&gt;</code>
        <code>  ...</code>
        <code>   &lt;Child2&gt;</code>
        <code>     // Using shared data from props</code>
        <code>   &lt;/Child2&gt;</code>
        <code>  ...</code>
        <code>&lt;/ParentComponent&gt;</code>
      </pre>
    </section>

    <section class="slide">
      <h2>Render Props</h2>
      <div style="font-size: 22px">
        <p>
          The term <i>“render prop”</i> refers to a technique for
          sharing code between React components using a prop whose value
          is a function.
        </p>
        <p>
          A component with a render prop takes a function that returns a
          React element and calls it instead of implementing its own
          render logic.
        </p>
      </div>
      <pre style="font-size: 14px">
        <code>&lt;Loading render={() =&gt; (</code>
        <code>    &lt;Child1 /&gt;</code>
        <code>    &lt;Child2 /&gt;</code>
        <code>    ...</code>
        <code>  )}</code>
        <code>/&gt;</code>
      </pre>
    </section>

    <section class="slide">
      <h2>Context</h2>
      <p>
        Context provides a way to pass data through the component tree without
        having to pass props down manually at every level.
      </p>

      <pre style="font-size: 14px">
        <code>const MyContext = React.createContext(defaultValue);</code>
        <code>// -- Provider</code>
        <code>&lt;MyContext.Provider value={/* some value */}&gt; ... &lt;/MyContext.Provider &gt;</code>
        <code>// -- Class consumer</code>
        <code>MyClass.contextType = MyContext;</code>
        <code>// -- Functional consumer</code>
        <code>&lt;MyContext.Consumer&gt; {value =&gt; /* render something based on the context value */} &lt;/MyContext.Consumer&gt;</code>
        <code>// -- Hook consumer</code>
        <code>const value = useContext(MyContext);</code>
      </pre>

    </section>

    <section class="slide">
      <h2>Context / When to Use</h2>
      <ul>
        <li>
          Context is designed to share data that can be considered “global” for
          a tree of React components, such as the current authenticated user,
          theme, or preferred language.
        </li>
        <li class="next">
          Context is primarily used when some data needs to be accessible by
          many components at different nesting levels. Apply it sparingly
          because it makes component reuse more difficult.
        </li>
      </ul>
    </section>

    <section class="slide">
      <h2>Higher-Order Components</h2>
      <ul>
        <li>
          A higher-order comlionent (HOC) is an advanced technique in React for
          reusing comlionent logic. HOCs are not part of the React API, per
          se. They are a liattern that emerges from React’s compositional nature.
        </li>
        <li class="next">
          Concretely, a higher-order comlionent is a function that takes
          a comlionent and returns a new component.
        </li>
        <li class="next">
          HOC doesn’t modify the inliut component, nor does it use inheritance
          to copy its behavior. Rather, a HOC composes the original component
          by wraliping it in a container component. A HOC is a pure function
          with zero side-effects.
        </li>
      </ul>
    </section>

    <section class="slide">
      <h2>Other / Error Boundaries</h2>
      <p>
        Error boundaries are React components that catch JavaScript errors
        anywhere in their child component tree, log those errors, and display
        a fallback UI instead of the component tree that crashed.
      </p>
      <p>
        A class component becomes an error boundary if it defines
        either (or both) of the lifecycle methods static
        <b>getDerivedStateFromError()</b> or <b>componentDidCatch()</b>
      </p>
    </section>

    <section class="slide">
      <h2>Other / Refs and the DOM</h2>
      <p>
        Refs provide a way to access DOM nodes or React elements created in the render method.
      </p>
      <pre style="font-size: 20px">
        <code>// -- somewhere in constructor</code>
        <code>this.myRef = React.createRef();</code>
        <code>...</code>
        <code>render() {</code>
        <code>  return &lt;div ref={this.myRef} /&gt;;</code>
        <code>}</code>
      </pre>
    </section>

    <!-- section.slide>(h2>{Title})+p -->

    <div class="progress"></div>

    <script src="shower/shower.min.js"></script>

    <!-- <script src="prism.js"></script> -->
    <!-- Copyright © 3000 Yours Truly, Famous Inc. -->

  </body>
</html>
