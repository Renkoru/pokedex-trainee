#+OPTIONS: num:nil toc:nil
#+REVEAL_ROOT: http://cdn.jsdelivr.net/reveal.js/3.0.0/
#+REVEAL_PLUGINS: (highlight)
#+Title: React course
#+Author: Maxim Rurenko
#+Email: mrurenko@gmail.com

* Regulations
- 4 lessons: React + Redux
- 2+ hours of lecture and about 4 hours of practice
- Questions - anytime.
- Если возникают вопросы или что-то непонятно - задавать вопросы.
- TODO Please move back your node tasks and let's start React!
* TODO Git
https://www.git-tower.com/learn/git/ebook/en/command-line/appendix/best-practices
* TODO Analysis paralysis
PICTURE HERE
** Preventing and overcoming
- Set limits
  Set initial constraints (deadline, time, people, money, resources,...) to what you are willing to commit
  for this plan. Setting deadlines: "Set a 'drop dead' date."[21] "Set a deadline and hold yourself accountable."[20] Limit the amount of info: "Curb your curiosity."[21] "Intentionally limit the amount of information you consume."[20]
- Clarify objectives and priorities
  Having a clear goal can simplify your decisions and actions for any project. "Know your main objective."[20]
- Remember nothing is perfect
  "Recognize that the moons will never align."[21]
- Take small iterative steps
  Agile development and design thinking are two recent movements emphasizing small iterations to discover the problem space. "Approach problems with an iterative mindset."[20] Decide something: "Stair step your decisions."[21] Resorting to Flipism, at least to reveal your preference, can resolve seeming equal choices. Do something: "Start before you feel ready."[20]
- Change number of options
  Increasing the number of options in the beginning increases the likelihood of including a good solution (Design thinking: divergent thinking, ideation). Decreasing the number of options later simplifies the decision process (Paradox of choice, convergent thinking).
- Add or remove emotion
  Decision making works best with a mix of rational, intuitive and emotional thinking.[22]
- Talk about it
  Talking with someone can get another viewpoint. This can also help reduce groupthink. "Get a sanity check."[21] "Get out of your own head and talk it out with someone else."[20] It doesn't even have to be a person (see Rubber duck debugging).
- Make your best decision
  Decision fatigue can affect or even prevent good decision making. "Structure your day for the decisions that matter most."[20] When you do make your decision, support it. "Make your decision the right one."[20]
** Adages
"Better one safe way than a hundred on which you cannot reckon." — Aesop's The Fox and the Cat
"The perfect is the enemy of the good." — Voltaire
"The best thing is to do the right thing; the next best is to do the wrong thing; the worst thing of all things is to stand perfectly still" — Alfred Henry Lewis (on Theodore Roosevelt and politics)
"The maxim 'Nothing avails but perfection' may be spelt shorter: 'Paralysis.'" — Winston Churchill
"Give them the third best to go on with; the second best comes too late, the best never comes" — Robert Watson-Watt
"Better a good decision quickly than the best decision too late." — Harold Geneen
* TODO Descisions you need to make
** File structure
Goals:
- Easy to navigate
- Easy to maintain
Have a structure, , .
- Productivity should be increased. Fuzzy searching files in text editor must be easier.
- Moving files should be effortless.
- Flexible and not too highly dictative. There should be some room for developers to do their own thing.
- Structure should encourage scalability, but also reusability.
- Structure should be simple enough for new team members to quickly get onboard and dive into the project.

- Grouping by features or routes
  Directory per view - This approach becomes relevant once you want to
  introduce routing to your application.
- Grouping by file type
- Your own way (Avoid too much nesting)

Possible folder names:
- components
- pages
- stores
- actions
- utils
- utils/api
- constants
- services
- (with nesting), pages(per route), stores, constants, actions,
 services (api requests) ,

File per concept - Perfect for small prototypes. You can split this up
as you get more serious with your application.

Directory per component - It is possible to push components to
directories of their own. Even though this is a heavier approach,
there are some interesting advantages as we'll see soon.

Directory per view - This approach becomes relevant once you want to
introduce routing to your application.
** File structure / What does a Dan says
move files around until it feels right
Click http://react-file-structure.surge.sh/
* TODO React is a view layer for your data managment
* TODO Types of components
- General. Business logic free (Atoms)
- Building blocks. Elements. Bigger components. NavBars, SideBars, Modals, ... (Molecules)
  “do one thing and do it well”
- Pages.
* Desired outcome
- Understand core concepts of React
- Comfortable to use React in your apps.
Лучше понять что нужно выделять в компонент, и что такое React компонент, зачем он нужен.
По возможности выносить всю бизнес логику, которая не относится к отображению, из React компонента.
* React
- A JavaScript library for building user interfaces.
- Declarative
- Component-Based
- Learn Once, Write Anywhere
* Livecoding time
- Goal: To understand what I am doing. Have a question - please ask!
- Do not repeat what I am doing. Just follow and ask questions
- I will share a code if it is needed
* React
** Declarative
- React makes it painless to create interactive UIs.
- Design simple views for each state in your application, and React will efficiently
  update and render just the right components when your data changes.
- Declarative views make your code more predictable and easier to debug.
** Component-Based
- Build encapsulated components that manage their own state, then compose them to make complex UIs.
- Since component logic is written in JavaScript instead of templates,
  you can easily pass rich data through your app and keep state out of the DOM.
** Learn Once, Write Anywhere
- We don’t make assumptions about the rest of your technology stack,
  so you can develop new features in React without rewriting existing code.
- React can also render on the server using Node and power mobile apps using React Native.
* React Elements
- Elements are the smallest building blocks of React apps.
- React elements are immutable. Once you create an element,
  you can’t change its children or attributes.
  An element is like a single frame in a movie: it represents the UI at a certain point in time.
- React Only Updates What’s Necessary
- In our experience, thinking about how the UI should look at any given moment rather than how to change it over time eliminates a whole class of bugs.
* Components and Props
- Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.
- The simplest way to define a component is to write a JavaScript function
- Don’t be afraid to split components into smaller components.
** Function and Class Components
- A function will be a valid React component if it accepts a single “props” object argument with data
  and returns a React element.
- Class components
** Composing Components
- Components can refer to other components in their output.
- This lets us use the same component abstraction for any level of detail.
** Props are Read-Only
- All React components must act like pure functions with respect to their props.
- Component must never modify its own props.
* About JSX
- JSX it is a syntax extension to JavaScript.
- We recommend using it with React to describe what the UI should look like.
- JSX may remind you of a template language, but it comes with the full power of JavaScript.
- React doesn’t require using JSX, but most people find it helpful as a visual aid when
  working with UI inside the JavaScript code.
- Babel compiles JSX down to React.createElement() calls.
** Embedding Expressions in JSX
- You can put any valid JavaScript expression inside the curly braces in JSX.
- For example, 2 + 2, user.firstName, or formatName(user) are all valid JavaScript expressions.
* State and Lifecycle
- Only class components have this
** Lifecycle Methods
- componentDidMount() method runs after the component output has been rendered to the DOM
- componentWillUnmount() method runs when the component going to be unmounted from DOM
** Using State Correctly
- Do Not Modify State Directly. Use setState()
- State Updates May Be Asynchronous
- State Updates are Merged
** The Data Flows Down
- Neither parent nor child components can know if a certain component is stateful or stateless,
  and they shouldn’t care whether it is defined as a function or a class.
- This is why state is often called local or encapsulated.
  It is not accessible to any component other than the one that owns and sets it.
- A component may choose to pass its state down as props to its child components.
* Handling Events
- Handling events with React elements is very similar to handling events on DOM elements.
- React events are named using camelCase, rather than lowercase
- With JSX you pass a function as the event handler, rather than a string
- Remeber to bind your event handlers to components 'this'.
* Conditional Rendering
- In React, you can create distinct components that encapsulate behavior you need.
- Then, you can render only some of them, depending on the state of your application.
** Element Variables
- You can use variables to store elements.
- This can help you conditionally render a part of the component while the rest of the output doesn’t change.
** Inline If with Logical && Operator
- You may embed any expressions in JSX by wrapping them in curly braces.
- This includes the JavaScript logical && operator.
** Inline If-Else with Conditional Operator
- Another method for conditionally rendering elements inline is to use the JavaScript
  conditional operator `condition ? true : false`
** Preventing Component from Rendering
- In rare cases you might want a component to hide itself even though it was rendered by another component.
- To do this return null instead of its render output.
* Lists and Keys
- A “key” is a special string attribute you need to include when creating lists of elements
- Keys help React identify which items have changed, are added, or are removed
- Keys should be given to the elements inside the array to give the elements a stable identity
- The best way to pick a key is to use a string that uniquely identifies a list item among its siblings
* Forms
- HTML form elements work a little bit differently from other DOM elements in React,
  because form elements naturally keep some internal state.
- This form has the default HTML form behavior of browsing to a new page when the user submits the form.
- If you want this behavior in React, it just works.
- But in most cases, it’s convenient to have a JavaScript function that handles the submission of
  the form and has access to the data that the user entered into the form.
** Controlled Components
- In HTML, form elements such as <input>, <textarea>, and <select> typically maintain their own state and update it based on user input.
- In React, mutable state is typically kept in the state property of components,
  and only updated with setState().
- We can combine the two by making the React state be the “single source of truth”.
- Then the React component that renders a form also controls what happens in that form on subsequent user input.
- An input form element whose value is controlled by React in this way is called a “controlled component”.
** Alternatives to Controlled Components
- Uncontrolled components
- this.input = React.createRef();
* Lifting State Up
- Often, several components need to reflect the same changing data.
- In React, sharing state is accomplished by moving it up to the closest common ancestor of the components that need it.
- This is called “lifting state up”.
- There should be a single “source of truth” for any data that changes in a React application.
* Composition vs Inheritance
- React has a powerful composition model, and we recommend using composition instead of inheritance
  to reuse code between components.
- At Facebook, they use React in thousands of components, and they haven’t found any use cases
  where we would recommend creating component inheritance hierarchies.
- Props and composition give you all the flexibility you need to customize a component’s look
  and behavior in an explicit and safe way.
- Remember that components may accept arbitrary props, including primitive values, React elements, or functions.
* Thinking in React
** Start With A Mock
** Step 1: Break The UI Into A Component Hierarchy
** Step 2: Build A Static Version in React
** Step 3: Identify The Minimal (but complete) Representation Of UI State
** Step 4: Identify Where Your State Should Live
** Step 5: Add Inverse Data Flow
** TODO Step 6: There should be as less business logic as possible. (Let it be just a view layer of you data)
* What to do next
- Setup React.
- Create base layout.
- Will share a basic layout
* Tools
- React DOM
- React Developer Tools
- React Router
- React
* Used resources
- React Docs: https://reactjs.org/docs/getting-started.html
* Links
- https://en.wikipedia.org/wiki/Analysis_paralysis
- https://www.studiogallant.com/the-fox-and-the-cat/
- Directory structure https://reactjs.org/docs/faq-structure.html
- Directory structure http://react-file-structure.surge.sh/
- Directory structure https://medium.com/@alexmngn/how-to-better-organize-your-react-applications-2fd3ea1920f1
- Directory structure https://hackernoon.com/the-100-correct-way-to-structure-a-react-app-or-why-theres-no-such-thing-3ede534ef1ed
- Directory structure https://survivejs.com/react/advanced-techniques/structuring-react-projects/

- http://bradfrost.com/blog/post/atomic-web-design/
